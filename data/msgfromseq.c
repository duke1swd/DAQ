/*
 * This program reads a csv file generated by read3data.c
 * It scans the opto channels to look for messages from the sequencer.
 * Those messages are formatted to stdout
 */

#include <stdio.h>
#include <getopt.h>
#include <stdlib.h>
#include <string.h>

char *myname;
char *input_file_name;
FILE *input;
int debug;
static int bit_time;
static int seq_log;

#define	MIN_BIT_TIME	3
#define	MAX_BIT_TIME	20
#define	BIT_TOLERANCE	1	// bit times are allowed to be off by this many samples

static void
set_defaults()
{
	debug = 0;
	bit_time = 5;	// DAQ is 5KHz, bit time is 1ms
	seq_log = 0;
}

static void
usage()
{
	set_defaults();
	fprintf(stderr, "Usage: %s [options] <input file>\n",
		myname);
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "\t-b <bit time (%d)>\n", bit_time);
	fprintf(stderr, "\t-d (increment debug level)\n");
	fprintf(stderr, "\t-L (process sequencer log message)\n");
	exit(1);
}

static void
grok_args(int argc, char **argv)
{
	int c;
	int errors;
	int nargs;

	errors = 0;
	myname = *argv;
	set_defaults();

	while ((c = getopt(argc, argv, "db:Lh")) != EOF)
	switch (c) {
	    case 'b':
		bit_time = atoi(optarg);
		break;
	    case 'L':
	    	seq_log++;
		break;
	    case 'd':
	    	debug++;
		break;
	    case 'h':
	    case '?':
	    default:
	    	usage();
		break;
	}

	if (bit_time < MIN_BIT_TIME || bit_time > MAX_BIT_TIME) {
		fprintf(stderr, "%s: bit time (%d) must be in the range "
				"[%d-%d]\n",
				myname,
				bit_time,
				MIN_BIT_TIME,
				MAX_BIT_TIME);
		errors++;
	}

	nargs = argc - optind;
	if (nargs != 1)
		usage();

	input_file_name = argv[optind];
	input = fopen(input_file_name, "r");
	if (input == NULL) {
		fprintf(stderr, "%s: cannot open input file %s for reading.\n",
			myname,
			input_file_name);
		errors++;
	}

	if (errors)
		usage();
}

/*
 * These routines are the state machine that decodes the input string
 */
int lineno;

static int t_bit_time;
static int field_width;
static int acc;

// states
static char ss;
#define	SS_SEARCH	0	// looking for possible start bit
#define	SS_S_3		1
#define	SS_S_2		2
#define	SS_S_1		3
#define	SS_FIELD_LEN	4
#define	SS_SCAN_BITS	5
#define	SS_STOP_BITS	6

// message states
static char msg_state;
static char msg_width;
#define	SOM	'\01'
#define	EOM	'\04'
#define	MSG_SEARCH	0
#define	MSG_RUN		1

/*
 * If we are looking for a message from the sequencer about the log
 * it should look like this:
 * 	SOM
 * 	11 (1 byte long)
 * 	log id (4 bytes long)
 * 	EOM
 */

#define	SEQ_ID	11
#define	SEQ_LOG_SOM	1
#define	SEQ_LOG_SEQ_ID	2
#define	SEQ_LOG_LOG_ID	3
#define	SEQ_LOG_EOM	4
static int seq_log_state;

static void
scanner_open()
{
	ss = SS_SEARCH;
	if (debug) printf("%5d: S_SEARCH\n", lineno);
	msg_state = MSG_SEARCH;
}

static void
scanner(int o0, int o1)
{
	int t;

	if (debug > 1) printf("scanner(%d %d) at %d\n", o0, o1, lineno);
	switch (ss) {
	    // scan looking for possible start bits
	    case SS_SEARCH:
	    	if (o0 == 1 && o1 == 1) {
			ss = SS_S_3;
			t_bit_time = 1;
			if (debug) printf("%5d: S_3\n", lineno);
		}
		break;
	    // how long does first bit last?
	    case SS_S_3:
	    	if (o0 == 1 && o1 == 1) {
			t_bit_time++;
		} else if (o1 == 1 && o0 == 0) {
			// got second start bit
			t = t_bit_time - bit_time;
			// Check length of first bit
			if (t >= -BIT_TOLERANCE && t <= BIT_TOLERANCE) {
				// length OK
				ss = SS_S_2;
				if (debug) printf("%5d: S_2 t_bit_time = %d\n", lineno, t_bit_time);
				t_bit_time = 1;
			} else {
				// start bit too long or too short
				ss = SS_SEARCH;
				if (debug) printf("%5d: S_SEARCH t_bit_time = %d\n", lineno, t_bit_time);
			}
		} else {
			// didn't find second start bit after first start bit
			ss = SS_SEARCH;
			if (debug) printf("%5d: SS_SEARCH no S_2\n", lineno);
		}
		break;
	    // scanning second start bit
	    case SS_S_2:
	    	if (o1 == 1 && o0 == 0) {
			t_bit_time++;
		} else if (o1 == 0 && o0 == 1) {
			t = t_bit_time - bit_time;
			// check length of second start bit
			if (t >= -BIT_TOLERANCE && t <= BIT_TOLERANCE) {
				ss = SS_S_1;
				if (debug) printf("%5d: S_1 t = %d\n", lineno, t);
				t_bit_time = 1;
			} else {
				// second start bit too long or too short
				if (debug) printf("%5d: SS_SEARCH t = %d\n", lineno, t);
				ss = SS_SEARCH;
			}
		} else {
			// didn't find third start bit after first start bit
			ss = SS_SEARCH;
			if (debug) printf("%5d: SS_SEARCH no S_1\n", lineno);
		}
		break;
	    case SS_S_1:
	    	if (t_bit_time < bit_time - BIT_TOLERANCE && (o1 != 0 || o0 != 1)) {
			// third start bit ended prematurely
			if (debug) printf("%5d: SS_SEARCH S_1 fail\n", lineno);
			ss = SS_SEARCH;
			break;
		}
		t_bit_time++;
		if (t_bit_time >= 3*bit_time/2) {
			t_bit_time = 0;
			ss = SS_FIELD_LEN;
			if (debug) printf("%5d: SS_FIELD_LEN\n", lineno);
		}
		break;
	    case SS_FIELD_LEN:
		if (t_bit_time == 0) {
			// When we enter the field we are centered on the right bits.
			// how wide is this message?  Convert from bytes to bits.
			msg_width = o1 * 2 + o0 + 1; // in bytes
			if (debug) printf("%5d:  msg_width = %d\n", lineno, msg_width);
			field_width = msg_width * 4; // in bits
			acc = 0;
		}
	    	t_bit_time++;
		if (t_bit_time < bit_time)
			// wait for proper spot to sample the bit
			break;
		t_bit_time = 0;
		if (debug) printf("%5d: SS_SCAN_BITS\n", lineno);
		ss = SS_SCAN_BITS;
		break;
	     case SS_SCAN_BITS:
		if (t_bit_time == 0) {
			acc <<= 2;
			acc |= (o1 << 1) | o0;
			if (debug) printf("%5d: acc=%x\n", lineno, acc);
			field_width--;
		}
	    	t_bit_time++;
		if (t_bit_time < bit_time)
			// wait for proper spot to sample the bit
			break;
		t_bit_time = 0;
		if (field_width == 0) {
			ss = SS_STOP_BITS;
			if (debug) printf("%5d: SS_STOP BITS\n", lineno);
		}
		break;
	     case SS_STOP_BITS:
		if (o1 != 0 || o0 != 0) {
			// if not stop bit, then this was all a mistake
			if (debug) printf("%5d: SS_SEARCH: no stop bits\n", lineno);
		} else
		// process message in acc!
		if (msg_state == MSG_SEARCH && msg_width == 1 && acc == SOM) {
			// got an SOM message
			if (seq_log) {
				if (seq_log_state == SEQ_LOG_SOM)
					seq_log_state = SEQ_LOG_SEQ_ID;
				else {
					printf("Unknown MSG looking for LOG ID\n");
					seq_log_state = SEQ_LOG_SOM;
				}
			} else 
				printf("MSG:\n");
			msg_state = MSG_RUN;
		} else if (msg_state == MSG_RUN && msg_width == 1 && acc == EOM) {
			if (seq_log) {
				if (seq_log_state != SEQ_LOG_EOM)
					printf("Unknown EOM looking for LOG ID\n");
				seq_log_state = SEQ_LOG_SOM;
			}
			msg_state = MSG_SEARCH;
		} else {
			if (seq_log_state == SEQ_LOG_SEQ_ID) {
				if (msg_width == 1 && acc == SEQ_ID)
					seq_log_state = SEQ_LOG_LOG_ID;
				else
					printf("SEQ LOG MESSAGE wrong ID (%d)\n", acc);
			} else if (seq_log_state == SEQ_LOG_LOG_ID) {
				if (msg_width == 4) {
					printf("Sequence Log ID: %d\n", acc);
					seq_log_state = SEQ_LOG_EOM;
				} else
					printf("SEQ_LOG_MESSAGE wrong width(%d)\n", msg_width);
			} else {
				if (seq_log) {
					printf("Unexpected message\n");
					seq_log_state = SEQ_LOG_SOM;
				}
				if (msg_state == MSG_SEARCH)
					printf(" ?");
				printf("\t");
				printf("%8x %8d (%d)\n", acc, acc, msg_width);
			}
		}
		// done.  Look for next one.
		ss = SS_SEARCH;
		if (debug) printf("%5d: SS_SEARCH: end of message\n", lineno);
	}
}

static void
scanner_close()
{
}

/*
 * Scan the input file
 */
static void
doit()
{
	int opt0, opt1;
	int r;
	int state;
	char lbuf[128];
	char match[] = "Channel 0, Channel 1, Channel 2, Opto 0, Opto 1\n";

	state = 0;
	lineno = 0;
	seq_log_state = SEQ_LOG_SOM;

	scanner_open();
	while (fgets(lbuf, sizeof lbuf, input) > 0) {
		lineno++;
		if (state == 0 && strcmp(lbuf, match) == 0) {
			state = 1;
			continue;
		}

		if (state == 1 && strncmp(lbuf, "EOF", 3) == 0)
			break;

		if (state == 0)
			continue;

		r = sscanf(lbuf, "%*d,%*d,%*d,%d,%d", &opt0, &opt1);
		if (r != 2) {
			fprintf(stderr, "%s: format error on line %d "
					"of file %s\n",
				myname,
				lineno,
				input_file_name);
			exit(2);
		}
		if (opt0 < 0 || opt0 > 1 || opt1 < 0 || opt1 > 1) {
			fprintf(stderr, "%s: opt format error on line %d "
					"of file %s\n",
				myname,
				lineno,
				input_file_name);
			exit(2);
		}
		scanner(opt0, opt1);
	}
	scanner_close();
	fclose(input);
}

int
main(int argc, char **argv)
{
	grok_args(argc, argv);
	doit();
	return 0;
}
