/*
 * This program reads a csv file generated by read3data.c
 * It scans the opto channels to look for messages from the sequencer.
 * Those messages are formatted to stdout
 */

#include <stdio.h>
#include <getopt.h>
#include <stdlib.h>
#include <string.h>

char *myname;
char *input_file_name;
FILE *input;
int debug;

static void
set_defaults()
{
	debug = 0;
}

static void
usage()
{
	set_defaults();
	fprintf(stderr, "Usage: %s [-d] <input file>\n",
		myname);
	exit(1);
}

static void
grok_args(int argc, char **argv)
{
	int c;
	int errors;
	int nargs;

	errors = 0;
	myname = *argv;
	set_defaults();

	while ((c = getopt(argc, argv, "dh")) != EOF)
	switch (c) {
	    case 'd':
	    	debug++;
		break;
	    case 'h':
	    case '?':
	    default:
	    	usage();
		break;
	}

	nargs = argc - optind;
	if (nargs != 1)
		usage();

	input_file_name = argv[optind];
	input = fopen(input_file_name, "r");
	if (input == NULL) {
		fprintf(stderr, "%s: cannot open input file %s for reading.\n",
			myname,
			input_file_name);
		errors++;
	}

	if (errors)
		usage();
}

/*
 * These routines are the state machine that decodes the input string
 */
int lineno;

#define	MIN_BIT_TIME	3
#define	MAX_BIT_TIME	10

static int bit_time;
static int t_bit_time;
static int field_width;
static int acc;

// states
static char ss;
#define	SS_SEARCH	0	// looking for possible start bit
#define	SS_S_3		1
#define	SS_S_2		2
#define	SS_S_1		3
#define	SS_FIELD_LEN	4
#define	SS_SCAN_BITS	5
#define	SS_STOP_BITS	6

// message states
static char msg_state;
static char msg_width;
#define	SOM	'\01'
#define	EOM	'\04'
#define	MSG_SEARCH	0
#define	MSG_RUN		1

static void
scanner_open()
{
	ss = SS_SEARCH;
	if (debug) printf("%5d: S_SEARCH\n", lineno);
	msg_state = MSG_SEARCH;
}

static void
scanner(int o0, int o1)
{
	int t;

	if (debug > 1) printf("scanner(%d %d) at %d\n", o0, o1, lineno);
	switch (ss) {
	    // scan looking for possible start bits
	    case SS_SEARCH:
	    	if (o0 == 1 && o1 == 1) {
			ss = SS_S_3;
			bit_time = 1;
			if (debug) printf("%5d: S_3\n", lineno);
		}
		break;
	    // how long does first bit last?
	    case SS_S_3:
	    	if (o0 == 1 && o1 == 1) {
			bit_time++;
		} else if (o1 == 1 && o0 == 0) {
			// got second start bit?
			if (bit_time >= MIN_BIT_TIME && bit_time <= MAX_BIT_TIME) {
				ss = SS_S_2;
				t_bit_time = 1;
				if (debug) printf("%5d: S_2 bit_time = %d\n", lineno, bit_time);
			} else {
				// start bit too long or too short
				ss = SS_SEARCH;
				if (debug) printf("%5d: S_SEARCH bit_time = %d\n", lineno, bit_time);
			}
		} else {
			// didn't find second start bit after first start bit
			ss = SS_SEARCH;
			if (debug) printf("%5d: SS_SEARCH no S_2\n", lineno);
		}
		break;
	    // scanning second start bit
	    case SS_S_2:
	    	if (o1 == 1 && o0 == 0) {
			t_bit_time++;
		} else if (o1 == 0 && o0 == 1) {
			t = t_bit_time - bit_time;
			if (t >= -1 && t <= 1) {
				ss = SS_S_1;
				if (debug) printf("%5d: S_1 t = %d\n", lineno, t);
				t_bit_time = 1;
			} else {
				// second start bit too long or too short
				if (debug) printf("%5d: SS_SEARCH t = %d\n", lineno, t);
				ss = SS_SEARCH;
			}
		} else {
			// didn't find third start bit after first start bit
			ss = SS_SEARCH;
			if (debug) printf("%5d: SS_SEARCH no S_1\n", lineno);
		}
		break;
	    case SS_S_1:
	    	if (t_bit_time < bit_time && (o1 != 0 || o0 != 1)) {
			// third start bit ended prematurely
			if (debug) printf("%5d: SS_SEARCH S_1 fail\n", lineno);
			ss = SS_SEARCH;
			break;
		}
		t_bit_time++;
		if (t_bit_time >= 3*bit_time/2) {
			t_bit_time = 0;
			ss = SS_FIELD_LEN;
			if (debug) printf("%5d: SS_FIELD_LEN\n", lineno);
		}
		break;
	    case SS_FIELD_LEN:
		if (t_bit_time == 0) {
			// When we enter the field we are centered on the right bits.
			// how wide is this message?  Convert from bytes to bits.
			msg_width = o1 * 2 + o0 + 1; // in bytes
			if (debug) printf("%5d:  msg_width = %d\n", lineno, msg_width);
			field_width = msg_width * 4; // in bits
			acc = 0;
		}
	    	t_bit_time++;
		if (t_bit_time < bit_time)
			// wait for proper spot to sample the bit
			break;
		t_bit_time = 0;
		if (debug) printf("%5d: SS_SCAN_BITS\n", lineno);
		ss = SS_SCAN_BITS;
		break;
	     case SS_SCAN_BITS:
		if (t_bit_time == 0) {
			acc <<= 2;
			acc |= (o1 << 1) | o0;
			if (debug) printf("%5d: acc=%x\n", lineno, acc);
			field_width--;
		}
	    	t_bit_time++;
		if (t_bit_time < bit_time)
			// wait for proper spot to sample the bit
			break;
		t_bit_time = 0;
		if (field_width == 0) {
			ss = SS_STOP_BITS;
			if (debug) printf("%5d: SS_STOP BITS\n", lineno);
		}
		break;
	     case SS_STOP_BITS:
		if (o1 != 0 || o0 != 0) {
			// if not stop bit, then this was all a mistake
			if (debug) printf("%5d: SS_SEARCH: no stop bits\n", lineno);
		} else
		// process message in acc!
		if (msg_state == MSG_SEARCH && msg_width == 1 && acc == SOM) {
			printf("MSG:\n");
			msg_state = MSG_RUN;
		} else if (msg_state == MSG_RUN && msg_width == 1 && acc == EOM) {
			printf("\n");
			msg_state = MSG_SEARCH;
		} else {
			if (msg_state == MSG_SEARCH)
				printf(" ?");
			printf("\t");
			printf("%8x %8d (%d)\n", acc, acc, msg_width);
		}
		// done.  Look for next one.
		ss = SS_SEARCH;
		if (debug) printf("%5d: SS_SEARCH: end of message\n", lineno);
	}
}

static void
scanner_close()
{
}

/*
 * Scan the input file
 */
static void
doit()
{
	int opt0, opt1;
	int r;
	int state;
	char lbuf[128];
	char match[] = "Channel 0, Channel 1, Channel 2, Opto 0, Opto 1\n";

	state = 0;
	lineno = 0;

	scanner_open();
	while (fgets(lbuf, sizeof lbuf, input) > 0) {
		lineno++;
		if (state == 0 && strcmp(lbuf, match) == 0) {
			state = 1;
			continue;
		}

		if (state == 1 && strncmp(lbuf, "EOF", 3) == 0)
			break;

		if (state == 0)
			continue;

		r = sscanf(lbuf, "%*d,%*d,%*d,%d,%d", &opt0, &opt1);
		if (r != 2) {
			fprintf(stderr, "%s: format error on line %d "
					"of file %s\n",
				myname,
				lineno,
				input_file_name);
			exit(2);
		}
		if (opt0 < 0 || opt0 > 1 || opt1 < 0 || opt1 > 1) {
			fprintf(stderr, "%s: opt format error on line %d "
					"of file %s\n",
				myname,
				lineno,
				input_file_name);
			exit(2);
		}
		scanner(opt0, opt1);
	}
	scanner_close();
	fclose(input);
}

int
main(int argc, char **argv)
{
	grok_args(argc, argv);
	doit();
	return 0;
}
